import RPi.GPIO as GPIO
import time
GPIO.setmode(GPIO.BCM)


GPIO.setup(23, GPIO.IN, pull_up_down=GPIO.PUD_UP)  #Button1
GPIO.setup(24, GPIO.IN, pull_up_down=GPIO.PUD_UP)  #Button2
GPIO.setup(16, GPIO.IN, pull_up_down=GPIO.PUD_UP)  #Button3
GPIO.setup(21, GPIO.OUT) #GLED
GPIO.setup(20, GPIO.OUT) #RLED
holder = [0,0,0,0]
pswd = [1,2,3,3]
state =1

# now we'll define the threaded callback function
# this will run in another thread when our event is detected
def my_callback(channel):
    button1 = GPIO.input(23)
    button2 = GPIO.input(24)
    button3 = GPIO.input(16)
    if state == 1:
        if button1:
            holder[0] = 1
        elif button2:
            holder[0] = 2
        elif button3:
            holder[0] = 3
    elif state == 2:
        if button1:
            holder[1] = 1
        elif button2:
            holder[1] = 2
        elif button3:
            holder[1] = 3
    elif state == 3:
        if button1:
            holder[2] = 1
        elif button2:
            holder[2] = 2
        elif button3:
            holder[2] = 3
    elif state == 4:
        if button1:
            holder[3] = 1
        elif button2:
            holder[3] = 2
        elif button3:
            holder[3] = 3
        if holder == pswd:
            GPIO.output(21, True)
            time.sleep(3)
        else:
            GPIO.output(20, True)
            time.sleeo(3)
    state += 1

GPIO.add_event_detect(23, GPIO.RISING, callback=my_callback)
GPIO.add_event_detect(24, GPIO.RISING, callback=my_callback)
GPIO.add_event_detect(16, GPIO.RISING, callback=my_callback)

while True:
    if state == 5:
        holder = [0, 0, 0, 0]
        state = 1

GPIO.cleanup()           # clean up GPIO on normal exit
